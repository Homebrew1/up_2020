# 提高可拓展性（上）

### 主要内容：





#### **提高可扩展性的目的**

+ 面对需求变更，方便需求更改
+ 减少代码修改的难度

#### 什么是好的可拓展

1. 需求的变更，不需要重写
2. 代码修改不会引起大规模变动
3. 方便加入新模块



### 01. 提高可拓展性的设计模式

------

#### 更好的更改代码

+ ##### 适配器模式 - 接口

```txt
目的： 通过写一个适配器，来代替 替换
应用场景： 面临接口不通用的问题
```

+ ##### 装饰者模式 - 方法作用

```txt
目的： 不重写方法的拓展方法
应用场景： 当一个方法需要拓展，但是又不好去修改方法
```

#### 解耦你的方法与调用

+ ##### 命令模式

```txt
目的： 解耦实现和调用，让双方互不干扰
应用场景： 调用的命令充满不确定性
```



### 02.基本结构

------

#### 适配器模式的基本结构

```js
var log = (function() {
    return window.console.log
})()
```

+ 我们公司想用log来代替console.log

**把之前的方法给到现在的接口名**

#### 装饰者模式的基本结构

```js
// 有一个他人写好的模块a，内部的方法b,模块为他人写好，不能修改，如何拓展b方法？
var a = {
    b: function() {}
};

function myb() {
    a.b()
    // 要拓展的方法
}
```

+ 我们新建一个自己的方法，在其内部调用b方法，并且再执行自己的方法。这样可以再不修改原对象的情况下，拓展行为

#### 命令模式的基本结构

```js
var command = (function() {
    var action = {}
    return function excute() {}
})();
```

+ 我们新建一个自己的方法，在其内部调用b方法，并且再执行自己的方法。这样可以再不修改原来对象的情况下，拓展行为



### 03.应用示例：

------

#### 适配器模式的示例

##### 1.框架的变更

> 需求：目前项目使用的A框架，现在改成了B，两个框架十分类似，但是有少数几个方法不同



##### 2.参数适配

> 需求：为了避免参数不适配产生问题，很多框架会有一个参数适配操作



#### 装饰者模式的示例

##### 1.拓展你的已有事件绑定

> 需求：现在项目改造，需要给input标签已经有的事件，增加一些操作



##### 2.Vue的数组监听

> 需求：vue中利用defineProperty可以监听对象，那么数组怎么办？





#### 命令模式的示例

##### 1.绘图命令

> 需求：封装一系列的canvas绘图命令



##### 2.绘制随机数量图片

> 需求：要做一个画廊，图片数量和排列顺序随机





### 最后总结

#### 适配器模式

当面临两个新老模块间接口api不匹配，可以用适配来转化api

#### 装饰者模式

当老的方法，不方便去直接修改，可以通过装饰者来增加功能

#### 命令模式

解耦实现与具体命令，让实现端和命令端扩展的都更轻松



