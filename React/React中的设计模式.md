# React中的设计模式

> 根React学设计模式：掌握编程“套路”，打造高质量应用

当我们谈论 React 设计模式时，实际上是在谈论“React组件的设计模式”。在React 设计模式中，最重要，也是最为大家所津津乐道的几个设计模式分别是：

+ **高阶组件（HOC）**
+ **Render Props**
+ **剥离有状态组件与无状态组件**

这些设计模式的本质：**以尽可能优雅的姿态，实现组件的逻辑复用**.

而我们今天即将探讨的这3种模式，也无出其右。



在这里，我们首先要做的事情，就是把每一个设计模式到底是什么，怎么用给弄清楚。在这个过程中，你会对“单一职责”和“开放封闭”这两个非常重要的设计原则有所认知。

在此基础上，你还要去思考：设计模式是否是万能的？如果不是，那么对框架来说，还有没有更加深刻、彻底的解法呢？

或许说到这儿，你会想到hooks（邪魅一笑），没错，最终还是要回到hooks。哈哈哈，让我们慢慢的，一步一步来，先来重温/一起来看这个 **高阶组件**这个概念。



## 高阶组件（Hign Order Component）: 最经典的组件逻辑复用方式



#### 什么是高阶组件

> 高阶组件（HOC）是React中用于复用组件逻辑的一种高级技巧。HOC自身不是React API 的一部分，它是一种基于React的组合特性而形成的设计模式 
>
> ​							-- React 官方

高阶组件在概念上沿袭了高阶函数（Hign Order  Function）。

高阶函数：**接收函数作为输入，或者输出另一个函数的一类函数，就是高阶函数**

相应的，**高阶组件指的就是参数为组件，返回值为新组件的函数。**没错，**高阶组件本质上是一个函数**。看个demo

```jsx
const withProps = (WrappedComponent) => {
  const targetComponent = (props) => (
    <div className='wrapper-container'>
    	<WrappedComponent {...props} />
    </div>
  )
  return targetComponent
}
```

上面代码中, withProps就是一个高阶组件。你可以想象一下，在多个组件中有相同的逻辑我们可以放入高阶组件中，然后去包裹对应组件即可，会得到“**一次封装，多处使用**”的优势，而不必要为每个组件都写一遍逻辑。

高阶组件不仅能帮助我们简化逻辑的引入过程，还可以帮助我们规避掉逻辑变更带来的烦琐的修改步骤。

**高阶组件可以帮助我们从根本上减少重复的编写和修改工作**，这不仅是高阶组件这一种模式的利好，更是“逻辑复用”这件事情的意义所在。



## Render Props : 逻辑复用的另一种思路

> render props 是指在React组件之间使用一个值为函数的 prop 共享代码的简单技术。
>
> ​											--- React 官方

#### 什么是 render props?

render props 是 React 中复用组件逻辑的另一种思路，它在实现上和高阶组件有异曲同工之妙  --- 两者都是把通用的逻辑提取到某一处，区别主要是在使用层面。

+ 高阶函数的使用姿势是用“函数”包裹“组件”
+ 而 render props 恰恰相反，它强调的是 “组件”包裹 “函数”

看一个简单的demo

```jsx
import React from 'react'
const RenderChildren = (props) => {
  return (
  	<>
    	{props.children(props)}
    </>
  )
}
```

RenderChildren 将渲染它所有的子组件。从这段代码里，你需要把握住两个要点：

1. render props 的载体应该是一个 **React 组件**，这一点是与 高阶组件不同的（高阶组件本质是 **函数**）
2. render props 组件正常工作的前提是它的 **子组件需要以函数形式存在**。

第一点相对明显，你可能对第二点有点难以理解，没关系，我们直接来看 RenderChildren 的使用方式，请看下面代码

```jsx
<RenderChildren>
  {() => <p> 我是 RenderChildren 的子组件 </p>}
</RenderChildren>
```

RenderChildren 本身是一个 React 组件，它可以包裹其他的react  组件。一般来说，我们习惯于看到的包裹形式是**“标签包裹着标签”**，也就是下面代码演示的这种效果：

```jsx
<RenderChildren>
  <p> 我是 RenderChildren 的子组件 </p>
</RenderChildren>
```

但在render props 这种模式下，他要求被 render props 组件标签包裹的一定是个函数，也就是所谓的 **函数作为子组件传入**， 这样一来，render props 组件就可以通过调用这个函数，传递props，从而实现和目标组件的通信了。



#### 理解 render props 的灵活之处

读到这里，你不免会产生这样的困惑：高阶组件和 render props 都能复用逻辑，那我到底该用哪个好呢?

这里先给出结论：**render props 将是你更好的选择，因为它更加灵活**

render props 和高阶组件的一个非常重要的区别，**在于对数据的处理上**：

+ 在高阶组件中，目标组件对于数据的获取没有主动权，**数据的分发逻辑全部收敛在高阶组件的内部；**
+ 而在render props 中，**除了父组件可以对数据进行分发处理之外，子组件也可以选择性地对数据进行接收**



#### 在设计原则：开放封闭原则

render props 更好的体现了开发封闭原则，**对拓展开放，对修改封闭**



## 有状态组件与无状态组件：“单一职责”原则在组件设计模式中的实践

#### 单一职责原则

单一职责原则又叫“单一功能原则”，它指的是一个类或者模块应该有且只有一个改变的原因。通俗来讲，就是说咱们的组件功能要尽可能地聚合，不要试图让一个组件做太多的事情。



#### 什么是有状态组件？什么是无状态组件？

函数组件，就是以函数的形态存在的React组件。早期并没有 React Hooks（react v16.8之后出现的 hooks）的加持，函数组件内部无法定义和维护 state ，因此它还有一个别名叫“无状态组件”。

看一个简单的无状态组件。

```jsx
function DemoFunction (props) {
  const {text} = props
  return (
    <div>
      <p> {`funciton 组件接收到的来自外界的文本内容是 [${text}]`} </p>
    </div>
  )
}
```

无状态组件不一定是函数组件，不维护内部状态的类组件也可以被认为是无状态组件。
相比之下，能够在组件内部维护状态、管理数据的组件，就是“有状态组件”。

#### 为何要剥离有状态组件和无状态组件

**核心目的就一个 -- 把数据处理和界面渲染这两个工作剥离开来**

为什么要这样做？别忘了React的核心特征是 “**数据驱动视图**”

```
UI = render(data)
UI = f(data)
```

因此对一个React 组件来说，他做的事情说到底无外呼是这两件事：

1. 处理事情（包括数据的获取、格式化、分发等）
2. 渲染界面

我们当然也可以在一个组件里面做完这两件事情，但这样不够优雅。

按照“单一职责”的原则，我们应该将数据处理的逻辑和界面渲染的逻辑剥离到不同的组件中去，这样功能模块的组合将会更加灵活，也会更加有利于逻辑的复用。此外，单一职责还能够帮助我们尽可能地控制变更范围，降低代码的维护成本：当数据相关的逻辑发生变化时，我们只需要去修改有状态组件就可以了，无状态组件将完全不受影响。





### why Hopoks:  设计模式解决不了所有的问题

设计模式虽好，但它并非万能。

就 React 来说，无论是高阶组件，还是 render props，两者的出现都是为了弥补类组件在“逻辑复用”这个层面的不灵活性。它们各自都有着自己的不足，这些不足包括但不限于以下几点：

1. 嵌套地狱问题，当嵌套层级过多后，数据源的追溯会变得十分困难

2. 较高的学习成本

3. props 属性命名冲突问题

4. ......

总体来看，“HOC/render props+类组件”这种研发模式，还是不够到位。当设计模式解决不了问题时，我们本能地需要从编程模式上寻找答案。于是便有了如今大家在 React 中所看到的 “函数式编程”对“面向对象”的补充（并且大有替代之势），有了今天我们所看到的“一切皆可 Hooks”的大趋势。

现在，当我们想要去复用一段逻辑时，第一反应肯定不是“高阶函数”或者“render props”，而应该是“自定义 Hook”。Hooks 能够很好地规避掉旧时类组件中各种设计模式带来的弊端，比如说它不存在嵌套地狱，允许属性重命名、允许我们在任何需要它的地方引入并访问目标状态等。由此可以看出，一个好的编程模式可以帮我们节约掉大量“打补丁”式地学习各种组件设计模式的时间。框架设计越合理，开发者的工作就越轻松。



#### 写在最后

我们回顾一下，在本文讲述了 React 组件的设计模式，认识了高阶组件、render props 两种经典设计模式的同时，也对“单一职责”“开放封闭”这两个重要的软件设计原则形成了初步的认识。

软件领域没有银弹，就算有，也不可能是设计模式。通过本讲的学习，相信你在认识设计模式的利好之余，也认识到了它的局限性。在此基础上，相信你会对 React-Hooks 及其背后的“函数式编程”思想建立更加强烈的正面认识。

亲爱的你，下期我们再会~（或许聊聊react 17）